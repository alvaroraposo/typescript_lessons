/*
The distributive property of conditional types allows for some interesting 
use cases when combined with never. It’s possible to create useful 
filter types as building blocks for advanced, self-maintaining types 
in our applications. Remember the ultimate goal: we want to 
model data and behavior but never maintain our types beyond the model.
*/
type Medium = {
  id: number;
  title: string;
  artist: string;
};

type TrackInfo = {
  duration: number;
  tracks: number;
};

type CD = Medium &
  TrackInfo & {
    kind: "cd";
  };

type LP = Medium &
  TrackInfo & {
    kind: "lp";
  };

type AllMedia = CD | LP;
type MediaKinds = AllMedia["kind"];

/*
These are our types. The function createMedium should work as follows:
1. The first argument is the type we want to create, either an LP or a CD.
2. The second argument is all the missing info we need to successfully create this medium. 
We don’t need the properties type, which we defined in our first argument,
nor the ID, as this will be generated by the function.
3. The function returns the newly created medium.
*/
declare function createMedium(kind, info): AllMedia;
declare function createMedium(kind: MediaKinds, info): AllMedia;
// We use a generic to bind the actual value type if we use a literal.
declare function createMedium<Kin extends MediaKinds>(
  kind: Kin,
  info
): AllMedia;

/*
Remember that conditional types are distributed over union
types, meaning that a conditional of unions is like a union
of conditionals. We can use this behavior to create a con-
ditional type that checks if each constituent of a union is a
subtype of the kind we are filtering for. If so, we return the
constituent. If not, we return never .
*/
type SelectBranch<Brnch, Kin> = Brnch extends { kind: Kin } ? Brnch : never;

/*
Note the naked type Brnch ! Let’s see what happens if we run
AllMedia through it, and select the branch for cd.
*/
// We create a type where we want to select the
// cd branch of the AllMedia Union
type SelectCD = SelectBranch<AllMedia, "cd">;

// This equals
// type SelectCD = SelectBranch<CD | LP, "cd">

// A conditional of unions is like a union of conditionals
//type SelectCD = SelectBranch<CD, "cd"> | SelectBranch<LP, "cd">

// Substitute for the implementation
/* type SelectCD =
    (CD extends { kind: "cd" } ? ? CD : never) |
    (LP extends { kind: "cd" } ? LP : never) */

// Evaluate!
/*
type SelectCD =
  // This is true! Awesome! Let’s return CD
  | (CD extends { kind: "cd" } ? CD : never)
  // This is false. let’s return never
  | (LP extends { kind: "cd" } ? LP : never);
*/

// Equal to
type SelectCD2 = CD | never;

/* 
As it says in the name, this can never
happen! That’s why TypeScript removes everything that
resolves to never from the union, if there are other constitu-
ents available. So SelectBranch<AllMedia, ‘cd’> resolves
to CD eventually.
*/

// Let’s update our return type.

declare function createMedium<Kin extends MediaKinds>(
  kind: Kin,
  info
): SelectBranch<AllMedia, Kin>;

/*
By binding Kin to the value type, we get the correct branch
of our union type. Handy! Also, if you use the pattern of
adding a kind property to create discriminated unions a lot,
the SelectBranch type becomes a reusable helper type in
your arsenal of types.
*/

/*
Extract

A much more generic type is the built-in helper type
Extract<A, B> . Extract<A, B> is defined as.

type Extract<A, B> = A extends B ? A : never;

The documentation says that it extracts from A those types that are assignable to B. 
This can be a set of keys, or (in our case) objects.
*/

// Resolves to LP
type SelectLP = Extract<AllMedia, { kind: "lp" }>;
